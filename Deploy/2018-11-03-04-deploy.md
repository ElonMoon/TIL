# 2018-11-03

#### 배포
배포는 단순히 로컬의 소스를 운영서버로 복하

최소한의 운영서버
웹(+API) + 마이크로서비스(배송조회, 우편번호검색)+모니터링

#### 어떻게 배포할 것인가
- 쉽고 관리하기 편한 방법
- 자동으로 배포
- 하루에도 여러 번 배포
- 배포 중 서비스가 중단되는 일이 없게
- 모든 서비스는 docker 를 이용해서 컨테이너 형태로 표준화해서 배포
- 테스트 서버에 동일한 방법으로 배포하고 테스트
- 시작은 서버 한 대지만 나중에 여러 대로 확장할 수 있게 설계

#### 왜 docker를 사용할까
Dockek는 가상의 공간을 이미지로 만들어 저장한 후 하나의 이미지에서
여러 개의 컨테이너를 생성할 수 있다. 이 말은 한 번 이미지를 만들면 여러 개의
컨테이너를 띄울 수 있다. 완전히 독립된 공간에서 실행되기 때문에 관리자는 컨테이너가
어떻게 구성되어 있는지 신경 쓸 필요가 없다. 도커 이미지를 만드는 방법은 `Dockerfile` 파일로 관리하기 때문에 원한다면 이지미 생성과정을 수정할 수 있다.

#### VMware vs Docker
마치 가상머신 같지만 분명 가상머신과는 다르다.
- HostOS 위에 또 다른 OS를 가상화 하는 것이 아니라 같은 OS에서 프로세스를 격리시켜 독립적으로 실행하는 것처럼 사용한다.
- 독립된 공간을 만들어서 프로세스를 실행하기 때문에 실행속도가 빠르고 일반적으로 CPU, Memory, Network의 성능저하가 거의 없다.
- Docker 의 생태계가 잘 구성 되어있어 편리한 툴, 다양한 문서들이 많고 커뮤니티가 잘 활성되어 있다.

#### 왜 인기가 있을까
Docker 가 나오기 전 가장 인기 있었던 가상화 시스템은 Xen. KVM 등이 있었다. 그러나 이런 기술들은 고급 개발자만 사용이 가능했고 가상화에 따른 성능 이슈도 많이 존재했다.
Docker 는 프로세스 격리라는 개념을 적극 도입해 성능 이슈를 줄이고, 일반 개발자들도 굉장히 사용하기 쉽게 개발할 수 있게 했다.

#### Docker의 약점
- 리눅스에서만 사용가능하다.
- 리눅스 커널에 따라 이슈가 약간 존재한다.(최신버전을 사용 못하는 클라우드에서는 문제가 있을 수도 있다)
- Docker 버전이 업그레이드 할 때마다 컨테이너가 죽는다.
- 포트 포워딩에 iptable을 사용하면서 생기는 보안 상 제약사항이 존재한다.

#### Docker를 이용한 배포
1. 확장성
- 이미지만 만들어 놓으면 컨테이너는 그냥 띄우기만 하면 된다.
- 다른 서버로 서비스를 옮기거나 새로운 서버에 서비스를 하나 더 띄우는 것은 'docker run' 명령어로 쉽게 할 수 있다.
- 개발서버를 띄우기도 편하고 테스트 서버를 띄우기도 편하다.

2. 표준성
- Docker를 사용하지 않을 경우,  ruby, nodejs, go, php 등 만든 서비스들의 배포방식은 제각각으로 다르다.
- 컨테이너라는 표준으로 서버를 배포, 모든 서비스들의 배포과정이 동일해진다.
- capistrano, fabric, ftp XXX

3. 이미지
- 이미지에서 컨테이너를 만들기 때문에 반드시 이미지를 만드는 과정이 필요하다.
- 이미지를 저장할 곳도 필요하다.
- 빌드 서버에서 이미지를 만들면 해당 이미지를 `distribution`에 저장하고 운영서버에서 이미지를 불러온다.

4. 설정
- 설정은 보통 환경변수로 제어한다.
- MYSQL_PASS=password 와 같이 컨테이너를 띄울 때 환경변수를 같이 지정한다.
- 하나의 이미지가 환경변수에 따라 동적으로 설정파일을 생성하도록 만들어야 한다.

5. 공유자원
- 컨테이너는 삭제 후 새로 만들면 모든 데이터가 초기화된다.
- 업로드 파일을 외부 스토리지와 연결해 사용하거나, S3 같은 별도의 저장소가 필요하다.
- 세션이나 캐시를 파일로 만들고 사용하고 있으면, memcached 나 redis 와 같은 외부로 분리해야한다.


```
# 이 밑은 수정이 필요!!! 꼭 수정해야 한다 !!!
```
#### MSA
인증
---> API
정적파일
---> API
메시지 프레임워크
---> API

#### BludGreen Deploy


#### 서버 아키텍쳐
- 모노리틱 아키텍쳐
- 서버리스 아키텍쳐
- 마이크로 서비스 아키텍쳐

#### 다중서버 환경 구성
- AWS ELB 활용, 로드밸런싱 환경 구축
- AWS Auto Scaling Group 이용한 다중 서버 구성
- Failover 아키텍쳐 구성

#### 서부 운영에 필요한 기초지식
- 포트포워딩
- 네트워크
- 가용성(?)

#### 운영 환경 구축(WebServer + WAS + DB Server)
- WebServer : Nginx
- WAS : Django(python3) + uWSGI
- DB Server : AWS RDS(PostgreSQL)

#### DevOps
- 모니터링(퍼포먼스, 로그, 메트릭)
- CI/CD

#### CI/CD, 모니터링 환경구성
- AWS Beanstalk 사용
- AWS Cloudwatch 구성해 모니터링
- Jenkins 활용한 CI/CD 파이프라인 구축
- ELK 스택을 구성해 로그 모니터링
- 가용성, 병목화 문제 해결

#### Docker
- Docker 명령어
- Dockerfile 작성
- AWS ECS를 활용한 Container orchestraion
	- AWS ECR에 n개의 Docker file push
	- EC2 n대를 구성한 후 ECR(docker file)을 기반으로 ECS 클러스터링
		- 환경설정
		- 컨테이너 별 포트 매핑
		- 컨테이너 Metric(시스템 자원) 배치
		
- AWS ALB(Application Load Balancer)를 활용한 컨테이너 로드밸런싱
- AWS Codepipeline을 활용한 CI/CD
	- Github webhook 설정
	- 컨테이너 별 자동 배치를 위한 Dockerfile 재작성
	- AWS CodeBulid를 통한 자동빌드(Docker) 설정
	- Codepipeline + Codebuild + ECS 를 활용한 무중단 배포
	
#### 서버리스 아키텍쳐 구축
- AWS S3 + AWS CloudFront CDN정적파일 전송 아키텍처 구축
- AWS API Gateway + AWS Lambda + AWS Dynamo DB 웹 서비스 구동을 위한 서버리스 아키텍처 구축
- 다양한 AWS Computing service

#### Test
- Apache jMeter
- NGrinder