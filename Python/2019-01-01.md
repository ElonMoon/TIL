# 2019-01-01
## Effective PYTHON
### Chapter1 파이썬 다운 생각

#### Better way 3. bytes, str, unicode의 차이점
파이썬 3에서는 bytes와 str 두 가지 타입으로 문자 시퀀스를 나타낸다.
bytes 인스턴스는 raw 8비트 값을 저장한다. str 인스턴스는 유니코드 문자를 저장한다.

파이썬 2에서는 str과 unicode 두 가지 타입으로 문자 시퀀스를 나타낸다.
str 인스턴스는 raw 8비트 값을 저장한다. unicode 인스턴스는 유니코드 문자를 저장한다.

**파이썬 3 str 인스턴스와 파이썬 2 unicode 인스턴스는 연관된 바이너리 인코딩이 없다.** (유니코드 문자를 바이너리 데이터로 표현하는 일반적인 방법 UTF-8)

유니코드 문자를 바이너리 데이터로 변환하려면 encode 메서드를 사용해야한다.
바이너리 데이터를 유니코드 문자로 변환하렴녀 decode 메서드를 사용해야한다.

파이썬 --> 외부 인터페이스

유니코드 인코딩 -> 디코딩

- Latin-1
ISO/IEC 8859는 컴퓨터에서 8비트로 문자를 나타내기 위한 ISO와 IEC의 공동 표준이다. ISO/IEC 8859-1, ISO/IEC 8859-2 등의 세부 표준이 제안되어 있다.
ASCII에 포함된 95자의 인쇄영역은 현대 영어로 정보를 표현하는데 충분하다. 하지만 로마문자를 쓰는 다른 언어에는 ASCII로 처리할 수 없는 추가적인 기호를 포함하고 있다.
예를 들면 ß(독일어), ñ(에스파냐어), å(스웨덴어와 북유럽 언어) 등이다. ISO 8859는 8비트로 구성된 바이트의 8번째 비트를 이용하여 128자의 추가적인 문자를 할당하여 이 문제를 처리하기 위해 제안되었다. 하지만 한 종류의 문자 집합만으로는 필요로 하는 모든 문자를 처리할 수 없어 여러 가지 매핑이 개발되었다.


- shift JIS
JIS X 201, JS X 0208 등을 사용하는 일본어 문자 인코딩, SJIS로도 불린다.

- Big5
타이완, 홍콩, 마카오에서 정체자에 쓰이는 중곡어 문자 인코딩 방식이다.
간체자를 사용하는 중국대륙은 GB문자집합을 대신 사용한다.

- MIME(Mulitpurpose Internet Mail Extensions)
전자우편ㅇ르 위한 언터넷 표준 포맷이다. 전자우편은 7비트 ASCII 문자를 사용해 전송하기 때문에, 8비트 이상의 코드를 사용하는 문자나 이진파일들은 MIME 포맷으로 변환되어 SMTP로 전송된다. 실질적으로 SMTP로 전송되는 대부분의 전자 우편은 MIME 형식이다.


파이썬 코드에서 생기는 문자열 이슈
- UTF-8 으로 인코드된 문자인 raw 8비트 값을 처리하려는 상황
- 인코딩이 없는 유니코드 문자를 처리하려는 상황



#### Better way 4. 복잡한 표현식 대신 헬퍼함수를 사용하자.
파이썬의 간결한 문법을 이용하면 많은 로직을 표현식 한 줄로 쉽게 작성할 수 있다.
```
해당 키값에 존재하는 값이 전혀 존재하지 않기 때문에 None 값이 뜬다.
```

파라미터가 없거라 비어 있으면 기본값으로 0을 할당하게 하면 좋을 것이다.
위 로직은 if문, 헬퍼함수까지는 사용할 필요까지는 없고 boolean 표현식으로 처리한다.

표현식이 복잡해지기 시작하면 최대한 빨지 해당 표현식을 작으 ㄴ조각으로 분할하고 로직을 헬퍼 함수로 옮기는 방안을 고려해야 한다. 무조건 짧은 코드를 만들기보다는 가독성을 선택하는 편이 낫다. 이렇게 이해하기 어려운 복잡한 표현식에는 파이썬의 함축적인 문법을 사용하면 안된다.

#### Better way 5. 시퀀스를 슬라이스 하는 방법을 알자
간단한 슬라이싱 대상은 내장 타입인 list, str, bytes이다.
__getitem__, __setitem__ 이라는 특별한 메서드를 구현하는 파이썬 클래스에서도 슬라이싱을 적용할 수 있다.
슬라이싱 기본 문법의 형태는 **somelist[start:end]** 이며 여기서 start 인덱스는 포함 end 인덱스는 제외된다.
리스트의 처음부터 슬라이스할 때는 보기 편하게 인덱스 0은 생략한다.
리스트 끝까지 슬라이스할 때도 마지막 인덱스도 생략한다.
슬라이싱의 결과는 완전히 새로운 리스트다. 물론 원본 리스트에 들어있는 객체에 대한 참조는 유지된다. 하지만 슬라이스한 결과를 수정해도 원본 리스트에 아무런 영향을 미치지 않는다.

```
assert condition
조건에 맞지 않으면 error를 낸다
if not condition:
	raise AssertionError()
디버깅 모드에서만 효과가 있고 릴리즈에서는 아무런 일도 하지 않기 때문에 예외처리랑
비슷하지만 좀 다른 상황에서 쓴다.
```


#### Betterway 6. 한 슬라이스에 start, end, stride 를 함께쓰지 말자
슬라이스의 스트라이드(stride: 간격)를 설정하는 특별한 문법이 있다.
이 문법을 사용하면 시퀀스를 슬라이스할 때 매 n번째 있는 아이템을 가져올 수 있다.

슬라이싱 문법의 stride 부분이 매우 혼란스러울 수 있따.
대괄호 안에 숫자가 세 개나 있으면 빽빽해서 있기 어렵다. 그래서 start와 end 인덱스가
stride와 연계되어 어떤 작용을 하는지 분명하지 않다. 특히 stride 가 음수인 경우는 더욱 그렇다.

stride 를 사용한다면 양수 값을 사용하고 start와 end 인덱스를 생갹하는게 좋다.
꼭 start와 end 인덱스를 사용해야할 경우 stride 적용한 결과를 변수에 할당하고
이 변수를 슬라이스한 결과를 다른 변수에 할당해서 사용해라.






#### Better way 7. map과 filter 대신 리스트 컴프리헨션을 사용하자
한 리스트에서 다른 리스트를 만들어내는 문법을 리스트 컴프리헨션이라 한다.
